// This module is OTT in terms of specifications and is just implemented as is so that it can be used for multiple purposes
const crypto = require('crypto'); // Used to generate cryptographically random seeds
let _seed = 0; // Buffer to store previous seed value

class PRNG {
	// Seed - generates random seeds or sets seed based on given value
	// Optional Parameter - newSeed can be Str || Int || Undefined
	seed(newSeed = undefined, saveState = true) {
		newSeed = _sha256(newSeed); // Hash parameter
		while (_seed == newSeed) { // Collision avoidance by rehashing
			newSeed = _sha256(newSeed);
		}
		if (saveState) _seed = newSeed; // Update seed for when the function is next called
		return newSeed; 
	}

	// LCG - generates pseudo-random number based on a single seed
	// Optional Parameter - value can be the result of the seed function or receive manual input to allow seeding
	lcg(value = this.seed()) {
		let a = 1664525; // Multiplier from Numerical Recipes
		let c = 1013904223; // Increment from Numerical Recipes
		let m = 2**32; // Modulus from Numerical Recipes
        
		let number = ((a*value + c) % m); // Formula: next value = (aX+c)%m
		number = number/2**32; // Brings back into range of 0-1
		return number;
	}
/*
let buffer = this.seed();
			if(!Array.isArray(states) && !states.isNullOrUndefined()) buffer = this.seed(states);
			states = [];
			states.push(this.lcg(buffer));
			for (let i = 1; i < 4; i++) {
				let result = this.lcg(this.seed(this.seed(states[i-1])))*(2**32);
				states.push(result);
			} // Use the LCG algorithm to produce four random seeds
			console.log(states);
		}
*/
	// XORShift - generates pseudo-random number based on four states
	// Optional Parameter - states is an array containing four integers, that can be user-provided or generated by a user-provided or generated seed
	xorShift(states = []) {
		let buffer;
		if (typeof(states) != "Number") {
			if (states.length < 4 && states.length != 1) {
				return "Invalid seed"
			} else {
				buffer = states[0];
			}
		} else {
			buffer = states;
		}

		states.push(this.lcg(buffer));
		for (let i = 1; i < 4; i++) {
			states.push(this.seed(this.lcg(states[i-1])*(2**32)));
		}
			
		let res = new XORGen(states[0], states[1], states[2], states[3]).random(); // Run XORGenerator using the given states
		return res;
	}
}

function _sha256(value = undefined) {
	if(value == undefined) {
		value = crypto.randomBytes(4); // A cryptographically random set of bytes that I believe is based loosely on time
		value = value.toString('hex'); // Converts to hex so it can be parsed as an integer value to use as a seed
		value = parseInt(value);
	}
	let sha256Hash = crypto.createHash('sha256').update(JSON.stringify(value)).digest(); // Hashes using the seed
	let parsedHash = sha256Hash.readUInt32BE(); // Reads output to big endian UINT to provide a better seed
	return parseInt(parsedHash);
}

class XORGen {
	constructor(a, b, c, d) {
		this.a = a; // State 0
		this.b = b; // State 1
		this.c = c; // State 2
		this.d = d; // State 3
	}

	next() {
		let t = this.a ^ ((this.a << 11) >>> 0); // S0 XORed by S0 shifted left 11times and zero filled right and unsign number
		this.a = this.b; // Swaps values round
		this.b = this.c;
		this.c = this.d;
		this.d = (this.d ^ (this.d >>> 19) ^ (t ^ (t >>> 8))) >>> 0; // New S3 XORed by itself unsign shifted right 19times and XORed by T XORed by T unsign shifted right 8times and then unsigned again
		return this.d; // Random number
	}

	random() {
		return this.next()/2**32; // Gets the next number and brings it into range
	}
}

module.exports = PRNG;
